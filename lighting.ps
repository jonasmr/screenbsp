//uniform sampler2D tex1; 
#version 150 


uniform sampler2D texLight;
uniform sampler2D texLightTile;
uniform sampler2D texLightIndex;

uniform float lightDelta;
uniform int NumLights;
uniform int MaxTileLights;
uniform int MaxLightTileIndex;
uniform int mode;
uniform vec2 ScreenSize;
uniform vec3 TileSize;


in vec3 fNormal;
in vec3 fWorldPos;
out vec4 Out0;


vec3 EvalLight(vec2 tc0, vec2 tc1)
{
	const float fAttenLength = 2.0;
	vec3 Pos = texture(texLight, tc0).xyz;
	vec3 LCol = texture(texLight, tc1).xyz;
	vec3 vToLight = fWorldPos - Pos;
	float fLen = length(vToLight);
	float fIntensity = (fLen / fAttenLength);
	fIntensity = 1.0 - fIntensity;
	fIntensity = min(max(fIntensity, 0.0), 1.0);
	fIntensity = fIntensity * fIntensity;
	vec3 vDir = -normalize(vToLight);
	float fAngle = max(dot(vDir, fNormal), 0.0);
	vec3 vDiffuse = fIntensity * fAngle * LCol;
	return vDiffuse;// + vec3(1,0,0);
}

void main(void)  
{

	vec3 Color = vec3(0,0,0);
	Color += vec3(0.4, 0.4, 0.4);
	vec3 Normal = normalize(fNormal);
	const float fAttenLength = 2.0;

	if(mode != 2)
	{
		vec2 Tile = floor(gl_FragCoord.xy / TileSize.z);
		vec2 TileCoord = Tile / TileSize.xy;
		vec2 LightInfo = texture(texLightTile, TileCoord).xy;
		float fBaseOffset = LightInfo.x*32768.0;
		float fCount = LightInfo.y*32768.0;
		float fMaxLights = float(MaxTileLights);
		float fScale = clamp(fCount / 5.0, 0.0, 1.0);
		if(mode == 1)
		{
			vec2 foo = (LightInfo.yy*32768.0) /fMaxLights;
			foo = (foo) * vec2(1.0, 1.0);
			Color = mix(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(foo, 0.0));//fScale + fWorldPos.x * 0.000001);
			Color += fWorldPos.x * 0.000001;
		}
		else
		{
			int nStart = int(floor(fBaseOffset + 0.5));
			int nEnd = nStart + int(floor(fCount + 0.5));
			for(int i = nStart; i < nEnd; ++i)
			{
				int u = i % 1024;
				int v = i / 1024;
				vec2 Coords = vec2(u / 1024.0, v / 1024.0);
				vec2 Index = texture(texLightIndex, Coords).xy;
				int lightIndex = int(Index.x * 32768.0);
				vec2 tcLight0 = vec2(lightDelta*(float(lightIndex)*2.0), 0);
				vec2 tcLight1 = vec2(tcLight0.x + lightDelta, 0);

				Color += EvalLight(tcLight0, tcLight1);


			}
			//vec2 foo = (LightInfo.yy*32768.0) /fMaxLights;
			//Color = mix(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(foo, 0.0));//fScale + fWorldPos.x * 0.000001);
			//Color += fWorldPos.x * 0.000001;
		}
	}
	else
	{
		for(int i = 0; i < NumLights; i++)
		{
			vec2 tc0 = vec2(lightDelta*(float(i)*2.0), 0);
			vec2 tc1 = vec2(tc0.x + lightDelta, 0);
#if 1
			Color += EvalLight(tc0, tc1);
#else
			vec3 Pos = texture(texLight, tc0).xyz;
			vec3 LCol = texture(texLight, tc1).xyz;
			vec3 vToLight = fWorldPos - Pos;
			float fLen = length(vToLight);
			float fIntensity = (fLen / fAttenLength);
			fIntensity = 1.0 - fIntensity;
			fIntensity = min(max(fIntensity, 0.0), 1.0);
			fIntensity = fIntensity * fIntensity;
			vec3 vDir = -normalize(vToLight);
			float fAngle = max(dot(vDir, fNormal), 0.0);
			vec3 vDiffuse = fIntensity * fAngle * LCol;
			Color += vDiffuse;
#endif
		}
	}
	Out0.xyz = Color;
	Out0.w = 1.0;
}


